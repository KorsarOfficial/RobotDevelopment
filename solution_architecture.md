# Архитектура решения для конкурсного задания

## Общая структура проекта

Проект будет организован в виде пакетов ROS2 со следующей структурой:

```
competitions_ws/
├── src/
│   ├── arm1650_config/           # Конфигурация манипулятора (из репозитория)
│   ├── arm1650_description/      # Описание URDF модели манипулятора (из репозитория)
│   ├── lamp_package/             # Пакет для управления световой индикацией (из репозитория)
│   ├── robot_control/            # Управление манипулятором (из репозитория)
│   ├── simulation_pkg/           # Пакет для запуска симуляции (из репозитория)
│   ├── webots/                   # Файлы симулятора Webots (из репозитория)
│   ├── robot_gui/                # Новый пакет для графического интерфейса (Модуль A)
│   ├── robot_automation/         # Новый пакет для автоматического управления (Модуль Б)
│   ├── robot_vision/             # Новый пакет для компьютерного зрения (Модуль В)
│   └── robot_ai/                 # Новый пакет для интеграции ИИ (Модуль Г)
```

## Модули решения

### Модуль A: Графический интерфейс управления (robot_gui)

**Компоненты:**
- `main_window.py` - Основное окно интерфейса с панелью управления
- `robot_api_client.py` - Клиент для взаимодействия с API робота
- `visualization.py` - Компоненты для визуализации состояния и данных
- `logger.py` - Система логирования действий и событий

**Используемые технологии:**
- PyQt5 для создания GUI
- ROS2 клиентские библиотеки для связи с роботом
- Matplotlib/OpenCV для визуализации данных

### Модуль Б: Автоматическое управление роботом (robot_automation)

**Компоненты:**
- `trajectory_planner.py` - Планирование траекторий движения манипулятора
- `automation_node.py` - Узел ROS2 для автоматического режима управления
- `safety_monitor.py` - Контроль безопасности и аварийных ситуаций
- `coordination_system.py` - Работа с локальными и глобальными координатами

**Используемые технологии:**
- ROS2 Control для управления манипулятором
- TF2 для координатных преобразований
- Алгоритмы планирования траекторий (RRT, PRM и др.)

### Модуль В: Компьютерное зрение (robot_vision)

**Компоненты:**
- `camera_handler.py` - Работа с камерами и видеопотоками
- `image_processor.py` - Обработка изображений (фильтрация, сегментация)
- `object_detector.py` - Детектирование и классификация объектов
- `vision_node.py` - Узел ROS2 для компьютерного зрения

**Используемые технологии:**
- OpenCV для обработки изображений
- NumPy для оптимизированных вычислений
- ROS2 Image Transport для передачи изображений
- Алгоритмы компьютерного зрения (контурный анализ, цветовая сегментация и т.д.)

### Модуль Г: Интеграция ИИ (robot_ai)

**Компоненты:**
- `dataset_generator.py` - Сбор и разметка данных для обучения моделей
- `model_trainer.py` - Обучение и валидация моделей ИИ
- `inference_engine.py` - Запуск инференса моделей
- `ai_safety_monitor.py` - Система адаптивной безопасности с ИИ
- `ai_node.py` - Узел ROS2 для интеграции ИИ с системой управления

**Используемые технологии:**
- TensorFlow/PyTorch для работы с нейросетями
- ONNX для оптимизации моделей
- OpenVINO для ускорения инференса
- Docker для контейнеризации моделей

## Интеграция модулей

Взаимодействие между модулями будет организовано через механизмы ROS2:
- **Темы (Topics)**: Для передачи данных между узлами в асинхронном режиме
- **Сервисы (Services)**: Для запросов/ответов между компонентами
- **Действия (Actions)**: Для долгосрочных задач с обратной связью
- **Параметры (Parameters)**: Для конфигурации узлов

## Архитектура данных

### Потоки данных:
1. Камеры → Модуль В (Обработка изображений) → Модуль Г (ИИ анализ) → Модуль Б (Планирование движений)
2. Датчики манипулятора → Модуль Б (Контроль безопасности) → Модуль A (Визуализация)
3. Пользовательский ввод → Модуль A (Интерфейс) → Модуль Б (Управление)

### Форматы данных:
- Изображения: ROS2 Image Messages
- Координаты: ROS2 Pose/PoseStamped/TF2
- Состояние робота: ROS2 JointState/RobotState
- Команды управления: ROS2 Trajectory Messages

## Разработка и тестирование

1. Разработка базовой архитектуры и структуры узлов ROS2
2. Реализация основных компонентов каждого модуля
3. Интеграционное тестирование в симуляторе Webots
4. Тестирование на реальном оборудовании (в финальной стадии)
5. Документирование кода и создание пользовательских инструкций 